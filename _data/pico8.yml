tweetcarts:
  basics:
    name: Tweetcart Basics
    author:
      name: Tweetcart Basics
    code: |-
      p={9,137,136,2,141,12,140,1,129,131,3,139,11,138,10,135}for i,c in pairs(p) do
      pal(i-1,c,1)end

      sc=.2
      ::_::
      cls()
      rectfill(0,0,24,13,2)
      print("twcart",1,1,1)
      print("basics",1,8,1)

      for x=0,128 do
      for y=0,70 do
      oc = pget(x*sc,y*sc)
      c = 0
      if oc == 2 then
        c = 7
      elseif oc == 1 then
      c = (7+x+y)/2
      end
      if oc != 0 then
        pset(x+1,y+28,c)
      end
      end
      end

      flip()
      goto _

  bluevertigo:
    name: Blue Vertigo
    author:
      name: Michał Rostocki
      twitter: von_rostock
    tweetcode: |-
      fillp(23130)s=sin::_::for r=16,128 do
      pal(r%6,({-15,1,-13,-4,12,6,7})[r%6],1)j=16/r+t()/8p=64+r/4*cos(j)q=64+r/4*s(j)circ(p,q,30-r,0)g,h=p+r,q
      for u=0,1,r/1400 do
      w=s(u)k=abs(s(u*2+j+s(j))-w)*min(r/20,3)l=r-k
      x=p+l*cos(u)y=q+w*l
      line(g,h,x,y,k+flr(k+.5)*16)g,h=x,y
      end
      end
      goto _

    studycode: |-
      -- typical 0101,1010 fill, in binary it looks like this:
      --    0101
      --    1010
      --    0101
      --    1010
      fillp(23130)

      -- start rendering loop
      ::_::

      -- loop through every radius from 16 to 128
      for r=16,128 do
        -- nice colour ramp.
        -- negative numbers are a short way to access the
        --  secret palette
        pal(r%6,({-15,1,-13,-4,12,6,7})[r%6],1)

        -- the time, offset by where in the tunnel we're
        --  currently drawing. deeper into the tunnel is
        --  future in time
        j=16/r+t()/8

        -- x centre of tunnel
        p=64+r/4*cos(j)
        -- y centre of tunnel
        q=64+r/4*sin(j)

        -- black centre circle.
        -- circ() ignores when r<0
        circ(p,q,30-r,0)

        -- g,h==x,y points for the initial line segment below
        g,h=p+r,q

        -- loop 0->1 on each radius from middle to outside of
        --  the tunnel
        for u=0,1,r/1600 do
          w=sin(u)

          -- k == the plasma for this line seg. of the tunnel
          --
          -- abs(sin(u*3+j+sin(j))-w) is a typical plasma
          --  pattern, just throw sin/cos on top of each other
          --  until it looks good~!
          -- `u` is where we are around the circle so the u*3
          --  affects how many separate 'tentacles' we have.
          -- `j` is time relative to how deep in the tunnel we
          --  are.
          --
          -- *min(r/20,3) because the pattern gets more
          --  vibrant (the brighter colours are added) as the
          --  tunnel gets closer to the camera
          k=abs(sin(u*3+j+sin(j))-w)*min(r/20,3)

          -- l == current radius of the tunnel, this changes
          --  based on the plasma value and is why the
          --  brighter colours stick out towards the centre of
          --  the tunnel, while the darker colours sink into
          --  the walls
          l=r+k

          -- centre of the tunnel + _current_ radius * cos(u)
          x=p+l*cos(u)
          -- centre of the tunnel + _current_ radius * sin(u)
          y=q+w*l

          -- draw this line segment
          line(g,h,x,y,k+flr(k+.5)*16)

          -- draw from this line segment to the next~
          g,h=x,y
        end
      end

      -- because the screen never hits a bad-looking state,
      --  there's no need to use flip here! :D
      goto _

  landofbsod:
    name: In the land of BSOD
    author:
      name: Michał Rostocki
      twitter: von_rostock
    tweetcode: |-
      cls()fillp(▒\1)pal({-4,12,6,7,7,7,-13,3,-5,-6},1)s=sin::_::x=rnd(128)m=78+s(x/192)*8y=rnd(96)w=x/6
      if(y<m)n=1w=x/2+t()*2
      g=y/512k=0for i=0,6do g*=2k+=.6^i*(s(s(g/2)/2-g*w/y)+s(g))end
      k=abs(k^3)+7
      if(y<m)k=min(k/4-7/4,4)+1
      if(y>93)k=1
      pset(x,16+y,k+(k+.5)\1*16)goto _

    studycode: |-
      cls()
      fillp(▒\1)
      pal({-4,12,6,7,7,7,-13,3,-5,-6},1)

      -- start drawing a pixel
      ::_::
      -- which random pixel are we rendering?
      x=rnd(128)
      y=rnd(96)
      -- this is the curve of the hill, just a gentle sin()
      m=78+sin(x/192)*8

      -- here's where we generate the patterns for the
      --  mountains and clouds.
      -- this effect is basically a bunch of sin()s tossed on
      --  top of each other (same as a normal plasma).
      --
      -- w is the X input to the plasma. however, it also
      --  affects the intensity of the end result (a higher
      --  'w' will result in more colours at the higher-end
      --  of the result). the ground is x/6 - pretty small so
      --  you get a long pattern. the sky is x/2 - much larger
      --  so the pattern gets condensed and is more intense,
      --  which is compensated for by adding the extra couple
      --  of white colours to the display palette :D
      --
      -- g is the 'density' of the random sins that get added
      --  on top. we start out with some just basic sins, and
      --  each of those 'i=0,6' loops below adds another layer
      --  of slightly-denser random values
      --
      -- 'i=0,6' means that 6 layers of more-specific sins are
      --  added on top of each other. you can see in the loop,
      --  with each layer 'g' gets doubled, and 'g' is used
      --  as a modifier in the sin calls.
      --
      -- k stores the output colour

      -- ground's x input
      w=x/6
      -- sky's x input, includes t() because the sky moves
      if(y<m) then
        w=x/2+t()*2
      end
      g=y/512
      k=0
      for i=0,6 do
        g*=2
        k+=.6^i*(sin(sin(g/2)/2-g*w/y)+sin(g))
      end

      -- convert k into a value that fits our palette.
      -- the +7 here shifts it to the green ground colours
      --  in our display palette
      k=abs(k^3)+7
      -- post-processing on the sky's colour value
      if (y<m) then
        -- because the initial 'w' value is so much higher for
        --  the sky, we need to do the /4 on 'k' to make it
        --  usable.
        -- the k/4 shifts it halfway, and the 7/4 shifts it
        --  the other half, down so the min value is now 0.
        --  then the +1 shifts it up so the minimum value is
        --  1 (because that's where our nice blue gradient
        --  starts in the display palette).
        k=min(k/4-7/4,4)+1
      end

      -- make blue border at the bottom of the screen
      if(y>93) then
        k=1
      end

      -- add the second colour for the fill pattern.
      -- the \1 is a short way to do flr() (see 'Integer
      --  Division') in the pico-8 manual).
      -- the *16 shifts it up - the high bits of the colour
      --  parameter are where the second colour lives.
      k+=((k+.5)\1)*16

      -- and finally, show the pixel!
      pset(x,16+y,k)

      -- because the screen never hits a bad-looking state,
      --  there's no need to use flip here! :D
      goto _

  moonandreflection:
    name: Moon and Reflection
    author:
      name: Luca Harris
      twitter: lucatron_
    tweetcode: |-
      cls()
      circfill(30,22,15,7)
      ::_::
      flip()
      srand()
      rectfill(0,50,127,127,0)
      for y=0,77 do
      z=77/(y+1)
      for i=0,z*8 do
      x=(rnd(160)+t()*150/z)%160-16
      w=cos(rnd()+t())*12/z
      if(w>0)line(x-w,y+50,x+w,y+50,max(1,pget(x,49-y/2)))
      end
      end
      goto _

    studycode: |-
      -- black night sky
      cls(0)

      -- the moon
      circfill(30,22,15,7)

      -- start rendering loop
      ::_::
      flip()

      -- re-initialize the random seed each loop so that rnd
      --  calls below will keep the same value.
      -- we do this because we use rnd() in a loop from top
      --  to bottom of the water to decide various things
      srand()

      -- cls() only the sea
      rectfill(0,50,127,127,0)

      -- loop from y=50 to y=127
      --  (the draw calls below use y+50 everywhere)
      for y=0,77 do
        -- how wide the reflection lines at this level are.
        -- in the distance they're super short, and they get
        --  longer as they come closer 77 -> 0, ~exponentially
        z=77/(y+1)

        -- z*8 random lines per y
        --
        -- some of these overlap and are going different
        --  speeds, which helps sell the shifting water effect
        for i=0,z*8 do

          -- x position of this line
          --
          -- rnd(160) is the base speed, and because we always
          --  seed using srand above, this stays the same for
          --  each line (better than generating the rnd values
          --  once and storing them in a table or an array).
          -- t()*150/z just makes it move, /z means slower
          --  near the horizon.
          -- %160 means that it'll loop back to 0 once it hits
          --  160, each line just loops.
          -- -16 so that rather than the full lines popping in
          --  on the left, they slide into the frame nicely
          x=(rnd(160)+t()*150/z)%160-16

          -- the width of the line, standard random-ish cos()
          --  that's smaller towards the horizon
          w=cos(rnd()+t())*12/z

          -- only draw when the width is over zero, fun~
          if (w>0) then
            -- max(1,pget(x,49-y/2) means that the colour will
            --  always either be 1 (water) or the grabbed
            --  pixel colour from top.
            -- note: the 'reflection' of the black sky is
            --  really just the lines not filling in the
            --  rectfill from above.
            --
            -- because x is random and the line is the same
            --  colour the whole way through, it creates real
            --  interesting shimmery reflections. this only
            --  looks good because the x-w and x+y means the
            --  colour is grabbed from the middle of the line
            line(x-w,y+50,x+w,y+50,max(1,pget(x,49-y/2)))
          end
        end
      end

      goto _

  owlhousespell:
    name: Owl House Spell
    author:
      name: bean borg
      twitter: beanborg
    tweetcode: |-
      i=63c=circ l=line::_::flip()a=t()/3if(a>1)memcpy(24576,24640,8127)for i=0,999do c(rnd(128),rnd(128),1,0)end c(i,i,60,10)
      c(i+60*sin(a),i+60*cos(a),1)c(i,i,49)c(i,39,9)l(i,111,i,49)l(54,39,i,15)l(72,39)l(60,49,18,83)l(108,83)l(66,49)l(55,77,70,70)l(55,70,70,i)goto _

    studycode: |-
      -- the default colour when running carts is grey (6),
      --  and that colour's used until the draw call below
      --  (that only runs after the outer circle gets
      --  completed) sets it to yellow (10)

      -- centre of the circle (x and y)
      i=63

      -- start the rendering loop
      ::_::
      flip()

      -- current time
      a=t()/3

      -- do this after we've drawn the whole circle! this
      --  works because we draw the circle based on 'a' too.
      if (a>1) then
        -- shift the screen up 1 pixel
        memcpy(24576,24640,8127)

        -- pixely fadeout!
        for i=0,999 do
          circ(rnd(128),rnd(128),1,0)
        end

        -- outer circle! the '10' here sets the colour to
        --  yellow, and that colour's used for all of the draw
        --  calls in the cart from now on, too (well, the
        --  pixely fadeout above sets the default colour to 0,
        --  but this sets it back to 10 right after that).
        circ(i,i,60,10)
      end

      -- draw the tiny circles.
      --
      -- so this is interesting! because cls() is never
      --  called, this one circ() call allows us to draw all
      --  of the little circles around the border. each new
      --  one is a brand-new circle in a different place and
      --  we just keep seeing the old, already-drawn ones.
      -- then when the fire-effect happens, all the old
      --  circles disappear into a puff of flames, gone with
      --  the wind
      circ(i+60*sin(a),i+60*cos(a),1)

      -- draw the background pattern.
      -- keep in mind, for the line() calls, that the cursor
      --  stays where the last draw happened, and starts from
      --  that point for the line calls that only contain a
      --  new x and y
      circ(i,i,49)
      circ(i,39,9)
      line(i,111,i,49)
      line(54,39,i,15)
      line(72,39)
      line(60,49,18,83)
      line(108,83)
      line(66,49)
      line(55,77,70,70)
      line(55,70,70,i)

      goto _

  pixtunnel:
    name: Tunnel
    author:
      name: Daniel Oaks
      twitter: pixienop
    tweetcode: |-
      pal({12,1,2,-8,8,14,15,-1,-7,9,10},1)::w::st=t()/2for i=1,250 do
      st -= .001+sin(st/5)*.003circ(64+sin(st)*30,64+cos(st)*30,i/2,(i*.044-t()*10)%11+1)end
      flip()goto w

    studycode: |-
      -- setup the display palette
      pal({12,1,2,-8,8,14,15,-1,-7,9,10},1)

      -- start of rendering loop
      ::w::
      -- get initial scene time
      st=t()/2

      -- from the centre of the tunnel to the outside
      for i=1,250 do
        -- the centre of the tunnel is in the 'future', so the
        --  outside of the tunnel is the past... so we minus
        --  time as we get further from the center.
        --
        -- the '+sin(st/5)*.003' introduces some strange time
        --  shifting that looks really interesting. makes it
        --  look like the tunnel speeds up and slows down.
        st -= .001+sin(st/5)*.003

        -- centre of this part of the tunnel
        x=64+sin(st)*30
        y=64+cos(st)*30

        -- draw the circle!
        -- i/2 means that the circle's radius expands as we
        --  go further out.
        -- i*.44 because that's a nice value, -t()*10 because
        --  that means the pattern is going away from the
        --  center, works with the way we adjust 'st' further
        --  up to create the *going further down the tunnel*
        --  look! if we really wanted to we could coordinate
        --  this with the time shifting above, but oh well.
        -- the %11+1 at the end restricts it to the first 11
        --  colours, and the +1 is to skip the first entry in
        --  pico8's current screen palette (plain black)
        circ(x,y,i/2,(i*.044-t()*10)%11+1)
      end

      -- display this frame to the screen. if we didn't use
      --  flip here, pico-8 would just grab new frames
      --  whenever, even if they're not finished yet
      flip()
      goto w

  prideflags:
    name: Pride Flags
    author:
      name: Daniel Oaks
      twitter: pixienop
    tweetcode: |-
      pal({8,10,12,136,141,1,5,14,7,137,2},1)n=rnd
      f="123456389:9;29579;"::w::r=t()
      srand(r)for i=0,3300 do pset(n(128),n(128),0)end
      srand()for j=0,70 do
      y=n(120)+sin(r/3+n())*8k=n(6)\1*3x=(n(200)-r*n(50))%200-3for i=1,3 do
      line(x,i+y,x+3,i+y,ord(f,k+i))end
      end
      flip()goto w

    studycode: |-
      -- setup display palette
      pal({8,10,12,136,141,1,5,14,7,137,2},1)

      -- flags - each three characters is a flag.
      --
      -- e.g. 123 are the first three chars on the screen,
      --  which here is the pan flag (red,yellow,blue).
      -- the : and ; are actually 10 and 11 - you can see this
      --  if you do 'print(chr(*))' with 57, 58, 59, or just
      --  check out an ascii chart.
      f="123456389:9;29579;"

      -- start of rendering loop
      ::w::

      -- dithered pixely fade-out. could do a cls() instead,
      --  but this looks pretty!
      srand(t())
      for i=0,3300 do
        pset(rnd(128),rnd(128),0)
      end

      -- seed rnd() calls to a consistent set of values, so
      --  each frame all the following rnd() calls will return
      --  the same values
      srand()

      -- 70 flags
      for j=0,70 do
        -- selecting which flag to use.
        -- rnd(6)\1 is equivalent to flr(rnd(6)) .
        -- and *3 because there's three colours in each flag
        k=rnd(6)\1*3

        -- simple up/down sin wave for the flag's height
        y=rnd(120)+sin(t()/3+rnd())*8

        -- x position of the flag.
        -- rnd(200) gives us our starting position.
        -- -t()*rnd(50) adjusts the speed of each flag.
        -- %200 wraps the flags back around to just past the
        --  right side of the screen when it hits the left.
        -- -3 so that the wrapping up there isn't visible, and
        --  only happens once the flag is not visible anymore
        x=(rnd(200)-t()*rnd(50))%200-3

        -- 3 stripes in each flag
        for i=1,3 do
          -- where the magic happens! so, the flag string is
          --  'f', and 'k+i' is the index of the specific
          --  colour we want to grab out of it.
          -- normally, we would do ord(f,k+i)-chr('0') ,
          --  to zero out the returned character, but since
          --  pico8's colours keep wrapping, and chr('0') is a
          --  multiple of 16, we don't actually need to! :D
          line(x,i+y,x+3,i+y,ord(f,k+i))
        end
      end

      -- display this frame to the screen. if we didn't use
      --  flip here, pico-8 would just grab new frames
      --  whenever, even if they're not finished yet
      flip()
      goto w

  rainbowtentacles:
    name: Rainbow Tentacles
    author:
      name: Daniel Oaks
      twitter: pixienop
    tweetcode: |-
      p={9,137,136,2,141,12,140,1,129,131,3,139,11,138,10,135}for i,c in pairs(p) do
      pal(i-1,c,1)end
      cm=0::w:: cm+=1cls(8)st=t()
      for b=0,2 do
      for i=1,190 do
      x=b*30j=x+i
      k=40+b*40-20+sin(i*.02+st*.2)*(3+b*5)w=i*.3circfill(j,k,w,i*cos(st*.05)+cm)pset(j-w*.7,k-w*.7,cm)end
      end
      flip()goto w

    studycode: |-
      -- colours that make up the rainbow pattern
      p={9,137,136,2,141,12,140,1,129,131,3,139,11,138,10,135}
      -- make 0->15 on the screen render as a rainbow
      for i,c in pairs(p) do
        pal(i-1,c,1)
      end

      -- colour movement adjuster
      cm=0

      -- start rendering loop
      ::w::
      -- every frame, the colours move 1 further along the
      --  tentacles with this variable
      cm+=1

      -- dark blue background
      cls(8)

      -- current time
      st=t()

      -- 0,1,2 - loop and create three tentacles
      for b=0,2 do
        -- loop through each 'slice' of the tentacle, from
        --  the smallest circles at the tip, to the big ones
        --  on the right side of the screen
        for i=1,190 do
          -- move the tip of the tentacle 30 pixels to the
          --  right for each one
          x=b*30
          -- (x) midpoint of this slice
          j=x+i
          -- (y) midpoint of this slice
          k=40+b*40-20+sin(i*.02+st*.2)*(3+b*5)
          -- width of this slice - very thin at the tip and
          --  much wider at the base
          w=i*.3
          -- draw the circle for this slice of tentacle
          circfill(j,k,w,i*cos(st*.05)+cm)
          -- draw the tiny 'ridge' that follows the tentacle
          --  along and shows its form off some more
          pset(j-w*.7,k-w*.7,cm)
        end
      end

      -- display this frame to the screen. if we didn't use
      --  flip here, pico-8 would just grab new frames
      --  whenever, even if they're not finished yet
      flip()
      goto w

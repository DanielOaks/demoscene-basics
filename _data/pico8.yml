tweetcarts:
  moonandreflection:
    tweetcode: |-
      cls()
      circfill(30,22,15,7)
      ::_::
      flip()
      srand()
      rectfill(0,50,127,127,0)
      for y=0,77 do
      z=77/(y+1)
      for i=0,z*8 do
      x=(rnd(160)+t()*150/z)%160-16
      w=cos(rnd()+t())*12/z
      if(w>0)line(x-w,y+50,x+w,y+50,max(1,pget(x,49-y/2)))
      end
      end
      goto _

    studycode: |-
      -- black night sky
      cls(0)

      -- the moon
      circfill(30,22,15,7)

      ::_::
      flip()

      -- re-initialize the random seed each loop so that rnd
      --  calls below will keep the same value.
      -- we do this because we use rnd() in a loop from top
      --  to bottom of the water to decide various things
      srand()

      -- cls() only the sea
      rectfill(0,50,127,127,0)

      -- loop from y=50 to y=127
      --  (the draw calls below use y+50 everywhere)
      for y=0,77 do
        -- how wide the reflection lines at this level are.
        -- in the distance they're super short, and they get
        --  longer as they come closer 77 -> 0, ~exponentially
        z=77/(y+1)
        
        -- z*8 random lines per y
        --
        -- some of these overlap and are going different
        --  speeds, which helps sell the shifting water effect
        for i=0,z*8 do
          
          -- x position of this line
          --
          -- rnd(160) is the base speed, and because we always
          --  seed using srand above, this stays the same for
          --  each line (better than generating the rnd values
          --  once and storing them in a table or an array).
          -- t()*150/z just makes it move, /z means slower
          --  near the horizon.
          -- %160 means that it'll loop back to 0 once it hits
          --  160, each line just loops.
          -- -16 so that rather than the full lines popping in
          --  on the left, they slide into the frame nicely
          x=(rnd(160)+t()*150/z)%160-16
          
          -- the width of the line, standard random-ish cos()
          --  that's smaller towards the horizon
          w=cos(rnd()+t())*12/z
          
          -- only draw when the width is over zero, fun~
          if (w>0) then
            -- max(1,pget(x,49-y/2) means that the colour will
            --  always either be 1 (water) or the grabbed
            --  pixel colour from top.
            -- note: the 'reflection' of the black sky is
            --  really just the lines not filling in the
            --  rectfill from above.
            --
            -- because x is random and the line is the same
            --  colour the whole way through, it creates real
            --  interesting shimmery reflections. this only
            --  looks good because the x-w and x+y means the
            --  colour is grabbed from the middle of the line
            line(x-w,y+50,x+w,y+50,max(1,pget(x,49-y/2)))
          end
        end
      end

      goto _

  bluevirtigo:
    tweetcode: |-
      fillp(23130)s=sin::_::for r=16,128 do
      pal(r%6,({-15,1,-13,-4,12,6,7})[r%6],1)j=16/r+t()/8p=64+r/4*cos(j)q=64+r/4*s(j)circ(p,q,30-r,0)g,h=p+r,q
      for u=0,1,r/1400 do
      w=s(u)k=abs(s(u*2+j+s(j))-w)*min(r/20,3)l=r-k
      x=p+l*cos(u)y=q+w*l
      line(g,h,x,y,k+flr(k+.5)*16)g,h=x,y
      end
      end
      goto _
    
    studycode: |-
      -- typical 0101,1010 fill
      fillp(23130)

      ::_::

      -- loop through every radius from 16 to 128
      for r=16,128 do
        -- nice colour ramp.
        -- negative numbers is short way to access the
        --  secret palette
        pal(r%6,({-15,1,-13,-4,12,6,7})[r%6],1)

        -- the time, offset by where in the tunnel we're
        --  currently drawing. deeper into the tunnel is
        --  future in time
        j=16/r+t()/8
        
        -- x centre of tunnel
        p=64+r/4*cos(j)
        -- y centre of tunnel
        q=64+r/4*sin(j)
        
        -- black centre circle.
        -- circ() ignores when r<0
        circ(p,q,30-r,0)
        
        -- g,h==x,y points for the initial line segment below
        g,h=p+r,q
        
        -- loop 0->1 on each radius from middle to outside of
        --  the tunnel
        for u=0,1,r/1600 do
          w=sin(u)
          
          -- k == the plasma for this line seg. of the tunnel
          --
          -- abs(sin(u*3+j+sin(j))-w) is a typical plasma
          --  pattern, just throw sin/cos on top of each other
          --  until it looks good~!
          -- `u` is where we are around the circle so the u*3
          --  affects how many separate 'tentacles' we have.
          -- `j` is time relative to how deep in the tunnel we
          --  are.
          --
          -- *min(r/20,3) because the pattern gets more
          --  vibrant (the brighter colours are added) as the
          --  tunnel gets closer to the camera
          k=abs(sin(u*3+j+sin(j))-w)*min(r/20,3)

          -- l == current radius of the tunnel, this changes
          --  based on the plasma value and is why the
          --  brighter colours stick out towards the centre of
          --  the tunnel, while the darker colours sink into
          --  the walls
          l=r+k

          -- centre of the tunnel + _current_ radius * cos(u)
          x=p+l*cos(u)
          -- centre of the tunnel + _current_ radius * sin(u)
          y=q+w*l
          
          -- draw this line segment
          line(g,h,x,y,k+flr(k+.5)*16)
          
          -- draw from this line segment to the next~
          g,h=x,y
        end
      end

      -- since this goes to 130% cpu use, no need to use flip!

      goto _
